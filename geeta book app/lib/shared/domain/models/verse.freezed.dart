// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'verse.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Verse _$VerseFromJson(Map<String, dynamic> json) {
  return _Verse.fromJson(json);
}

/// @nodoc
mixin _$Verse {
  String get id => throw _privateConstructorUsedError;
  String get chapterId => throw _privateConstructorUsedError;
  int get verseNumber => throw _privateConstructorUsedError;
  String get textSanskrit => throw _privateConstructorUsedError;
  String get textTransliteration => throw _privateConstructorUsedError;
  String get translationEnglish => throw _privateConstructorUsedError;
  String get translationHindi => throw _privateConstructorUsedError;
  String get explanation => throw _privateConstructorUsedError;
  String? get videoUrl => throw _privateConstructorUsedError;
  String? get audioUrl => throw _privateConstructorUsedError;
  List<String> get images => throw _privateConstructorUsedError;
  bool get isCompleted => throw _privateConstructorUsedError;
  DateTime? get completedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VerseCopyWith<Verse> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VerseCopyWith<$Res> {
  factory $VerseCopyWith(Verse value, $Res Function(Verse) then) =
      _$VerseCopyWithImpl<$Res, Verse>;
  @useResult
  $Res call(
      {String id,
      String chapterId,
      int verseNumber,
      String textSanskrit,
      String textTransliteration,
      String translationEnglish,
      String translationHindi,
      String explanation,
      String? videoUrl,
      String? audioUrl,
      List<String> images,
      bool isCompleted,
      DateTime? completedAt});
}

/// @nodoc
class _$VerseCopyWithImpl<$Res, $Val extends Verse>
    implements $VerseCopyWith<$Res> {
  _$VerseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? chapterId = null,
    Object? verseNumber = null,
    Object? textSanskrit = null,
    Object? textTransliteration = null,
    Object? translationEnglish = null,
    Object? translationHindi = null,
    Object? explanation = null,
    Object? videoUrl = freezed,
    Object? audioUrl = freezed,
    Object? images = null,
    Object? isCompleted = null,
    Object? completedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      chapterId: null == chapterId
          ? _value.chapterId
          : chapterId // ignore: cast_nullable_to_non_nullable
              as String,
      verseNumber: null == verseNumber
          ? _value.verseNumber
          : verseNumber // ignore: cast_nullable_to_non_nullable
              as int,
      textSanskrit: null == textSanskrit
          ? _value.textSanskrit
          : textSanskrit // ignore: cast_nullable_to_non_nullable
              as String,
      textTransliteration: null == textTransliteration
          ? _value.textTransliteration
          : textTransliteration // ignore: cast_nullable_to_non_nullable
              as String,
      translationEnglish: null == translationEnglish
          ? _value.translationEnglish
          : translationEnglish // ignore: cast_nullable_to_non_nullable
              as String,
      translationHindi: null == translationHindi
          ? _value.translationHindi
          : translationHindi // ignore: cast_nullable_to_non_nullable
              as String,
      explanation: null == explanation
          ? _value.explanation
          : explanation // ignore: cast_nullable_to_non_nullable
              as String,
      videoUrl: freezed == videoUrl
          ? _value.videoUrl
          : videoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      audioUrl: freezed == audioUrl
          ? _value.audioUrl
          : audioUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value.images
          : images // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isCompleted: null == isCompleted
          ? _value.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VerseImplCopyWith<$Res> implements $VerseCopyWith<$Res> {
  factory _$$VerseImplCopyWith(
          _$VerseImpl value, $Res Function(_$VerseImpl) then) =
      __$$VerseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String chapterId,
      int verseNumber,
      String textSanskrit,
      String textTransliteration,
      String translationEnglish,
      String translationHindi,
      String explanation,
      String? videoUrl,
      String? audioUrl,
      List<String> images,
      bool isCompleted,
      DateTime? completedAt});
}

/// @nodoc
class __$$VerseImplCopyWithImpl<$Res>
    extends _$VerseCopyWithImpl<$Res, _$VerseImpl>
    implements _$$VerseImplCopyWith<$Res> {
  __$$VerseImplCopyWithImpl(
      _$VerseImpl _value, $Res Function(_$VerseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? chapterId = null,
    Object? verseNumber = null,
    Object? textSanskrit = null,
    Object? textTransliteration = null,
    Object? translationEnglish = null,
    Object? translationHindi = null,
    Object? explanation = null,
    Object? videoUrl = freezed,
    Object? audioUrl = freezed,
    Object? images = null,
    Object? isCompleted = null,
    Object? completedAt = freezed,
  }) {
    return _then(_$VerseImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      chapterId: null == chapterId
          ? _value.chapterId
          : chapterId // ignore: cast_nullable_to_non_nullable
              as String,
      verseNumber: null == verseNumber
          ? _value.verseNumber
          : verseNumber // ignore: cast_nullable_to_non_nullable
              as int,
      textSanskrit: null == textSanskrit
          ? _value.textSanskrit
          : textSanskrit // ignore: cast_nullable_to_non_nullable
              as String,
      textTransliteration: null == textTransliteration
          ? _value.textTransliteration
          : textTransliteration // ignore: cast_nullable_to_non_nullable
              as String,
      translationEnglish: null == translationEnglish
          ? _value.translationEnglish
          : translationEnglish // ignore: cast_nullable_to_non_nullable
              as String,
      translationHindi: null == translationHindi
          ? _value.translationHindi
          : translationHindi // ignore: cast_nullable_to_non_nullable
              as String,
      explanation: null == explanation
          ? _value.explanation
          : explanation // ignore: cast_nullable_to_non_nullable
              as String,
      videoUrl: freezed == videoUrl
          ? _value.videoUrl
          : videoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      audioUrl: freezed == audioUrl
          ? _value.audioUrl
          : audioUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isCompleted: null == isCompleted
          ? _value.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
      completedAt: freezed == completedAt
          ? _value.completedAt
          : completedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VerseImpl implements _Verse {
  const _$VerseImpl(
      {required this.id,
      required this.chapterId,
      required this.verseNumber,
      required this.textSanskrit,
      required this.textTransliteration,
      required this.translationEnglish,
      required this.translationHindi,
      required this.explanation,
      this.videoUrl,
      this.audioUrl,
      final List<String> images = const [],
      this.isCompleted = false,
      this.completedAt})
      : _images = images;

  factory _$VerseImpl.fromJson(Map<String, dynamic> json) =>
      _$$VerseImplFromJson(json);

  @override
  final String id;
  @override
  final String chapterId;
  @override
  final int verseNumber;
  @override
  final String textSanskrit;
  @override
  final String textTransliteration;
  @override
  final String translationEnglish;
  @override
  final String translationHindi;
  @override
  final String explanation;
  @override
  final String? videoUrl;
  @override
  final String? audioUrl;
  final List<String> _images;
  @override
  @JsonKey()
  List<String> get images {
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_images);
  }

  @override
  @JsonKey()
  final bool isCompleted;
  @override
  final DateTime? completedAt;

  @override
  String toString() {
    return 'Verse(id: $id, chapterId: $chapterId, verseNumber: $verseNumber, textSanskrit: $textSanskrit, textTransliteration: $textTransliteration, translationEnglish: $translationEnglish, translationHindi: $translationHindi, explanation: $explanation, videoUrl: $videoUrl, audioUrl: $audioUrl, images: $images, isCompleted: $isCompleted, completedAt: $completedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VerseImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.chapterId, chapterId) ||
                other.chapterId == chapterId) &&
            (identical(other.verseNumber, verseNumber) ||
                other.verseNumber == verseNumber) &&
            (identical(other.textSanskrit, textSanskrit) ||
                other.textSanskrit == textSanskrit) &&
            (identical(other.textTransliteration, textTransliteration) ||
                other.textTransliteration == textTransliteration) &&
            (identical(other.translationEnglish, translationEnglish) ||
                other.translationEnglish == translationEnglish) &&
            (identical(other.translationHindi, translationHindi) ||
                other.translationHindi == translationHindi) &&
            (identical(other.explanation, explanation) ||
                other.explanation == explanation) &&
            (identical(other.videoUrl, videoUrl) ||
                other.videoUrl == videoUrl) &&
            (identical(other.audioUrl, audioUrl) ||
                other.audioUrl == audioUrl) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            (identical(other.isCompleted, isCompleted) ||
                other.isCompleted == isCompleted) &&
            (identical(other.completedAt, completedAt) ||
                other.completedAt == completedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      chapterId,
      verseNumber,
      textSanskrit,
      textTransliteration,
      translationEnglish,
      translationHindi,
      explanation,
      videoUrl,
      audioUrl,
      const DeepCollectionEquality().hash(_images),
      isCompleted,
      completedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VerseImplCopyWith<_$VerseImpl> get copyWith =>
      __$$VerseImplCopyWithImpl<_$VerseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VerseImplToJson(
      this,
    );
  }
}

abstract class _Verse implements Verse {
  const factory _Verse(
      {required final String id,
      required final String chapterId,
      required final int verseNumber,
      required final String textSanskrit,
      required final String textTransliteration,
      required final String translationEnglish,
      required final String translationHindi,
      required final String explanation,
      final String? videoUrl,
      final String? audioUrl,
      final List<String> images,
      final bool isCompleted,
      final DateTime? completedAt}) = _$VerseImpl;

  factory _Verse.fromJson(Map<String, dynamic> json) = _$VerseImpl.fromJson;

  @override
  String get id;
  @override
  String get chapterId;
  @override
  int get verseNumber;
  @override
  String get textSanskrit;
  @override
  String get textTransliteration;
  @override
  String get translationEnglish;
  @override
  String get translationHindi;
  @override
  String get explanation;
  @override
  String? get videoUrl;
  @override
  String? get audioUrl;
  @override
  List<String> get images;
  @override
  bool get isCompleted;
  @override
  DateTime? get completedAt;
  @override
  @JsonKey(ignore: true)
  _$$VerseImplCopyWith<_$VerseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
